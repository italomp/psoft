SPRING

> Instalar spring 3 e usar dependência web no projeto.
	
	Thymeleaf, Web, JPA, H2, devTools (ou Postgree ou MySQL).
	
	obs: H2 é um banco em memória. Se fizer besteira, basta reiniciar a plicação.
	versão do spring 2.1.4
	

> iniciar projeto
	new spring starter project

> @SpringBootAplication (MAIN)
	A classe marcada com isso, sobe o servidor spring

> resources\application.properties
	Arquivo de configuração do projeto.
	
	Usado para interair com o BD.

> pom.xml
	Contém todas as informações sobre o projeto, assim como as dependências escolhidas.

	Caso precise adicionar nova dependência, basta adicioná-la aqui.

> colocar servidor pra rodar
	run as > Spring Boot App

> @Controller e @RestController

	O controller é quem vai receber a requisição do cliente, resolver ou delegar para quem sabe resolver
	aquela requisição.

	Usamos diferentes controllers para gerenciar as requisições a diferentes recursos, de forma independente.

	@Controller
		retorna um template que vai ser carregado na view.

		IMPORTANTE: Se eu for retornar um template, tenho que colocar "return nomeTemplate", onde nomeTemplate
		é o nome do template (arquivo html) que está em resources/templates

	@RestController
		retorna um JSON (ou XML...) que vai ser carregado na view. (Não recarrego toda a view, apenas o json novo)

		Combinação de @Controller com @ResponseBody
		Retorna um JSON um XML...

		Alternativa:
		Usar a notação @Controller na classe e @ResponseBody nos métodos que desejo retornar o JSON

		IMPORTANTE: Se minha API inteira retorna JSON, uso @RestControler. Menos anotações na classe.

			    obs: Não precisamos fazer a conversão dos objetos em JSON, o framework faz isso pra gente.

> Separar todas as camadas do projeto em pacotes (boa prática)
	ex: pacote para controllers, serviços, models

> GetMapping("/minha_rota")
	cria uma rota para ser acessada por um HTTP GET

	Rota: caminho para chegar ao recurso.

	Recurso: informação gerenciada pelo sistema.

> @RequestMapping({"rota"})
	posso usar o mesmo controller para diferentes rotas?

	"v1" é uma convenção muito usada em APIs nas quais queremos fazer upgrades mas temos que manter versões antigas
	para garantir compatibilidade om serviços que já usam essa rota.

	v1 (versão 1), v2 (versão 2), v3 (versão 3)...

	lembrar dos princípios HTTP: não faz sentido termos rotas do tipo: /criarProduto, /deletarProduto...

> ResponseEntity
	uma classe wrapper que representa o corpo de um response e seu status.

	pelo que vi, ao invés de trabalhar direto cm objetos, vou usar ResponseEntity.
	Nela posso encapsular objeto e status da response.

> @PathVariable
	indica que ese método espera da request, o parâmetro id.

> @PostMapping
	diz que qualquer request POST que tiver a URI do meu controller + "/" deve chamar o método create.

> @ResponseBody
	diz ao spring que aquele método espera um tipo específico de objeto
	ex: method(@ResponseBody Product product)

> @DeleteMapping
	diz para o spring que qualquer URI que tenha a rota do controller + "/{id}" deve chamar o método delete (
	que no caso é o método que tem a notação) 

> @PutMapping
	diz ao spring que qaulquer resquest PUT com URI do controller + "/" deve chamar o método update 
	(que no caso é o método que que tem a notação).

	Pelo que entendi o PUT atualiza todo o repositório, pois não recebe id no URI.
	
> @RequestParam(name="name", required=false, defaultValue="World")
	recebe um nome como parametro e mostra na URL

	ex: servidor:8080/hello?name=Raquel

> Model
	modelo que guarda valores de certos atributos

	dar nome ao model
	model.addAttribute("name", name);

	IMPORTANTE: adicionamos ao model pares (chave, valor), onde valor é um objeto.
	ex: model.addAttribute("name", name);
	    model.addAttribute("hora", LocalTime.now());

> Error controler
	o controler precisa impementar a interface "ErrorController"

> Dependência Web
	com essa dependência conseguimos usar o servidor Tomcat que é um servidor web java e
	utilizamos ele para subir a nossa aplicação.

> Depentência para o servidor atualizar sozinho quando houver mudanças no back (devtools)
	<dependency>
   
		<groupId>org.springframework.boot</groupId>
   
		<artifactId>spring-boot-devtools</artifactId>
   
		<optional>true</optional>

	</dependency>

> Dependência para permitir CRUD (Thymeleaf)
	<dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-thymeleaf</artifactId>
        </dependency> 

> @ComponentScan()
	A classe main marcada com @SpringBootApplication contém algumas marcações, entre elas
	@ComponentScan() que diz onde os controllers estão. Por default ela mostra que os 
	controllers estão no mesmo pacote do main (@SpringBootApplication).
	Se eles estiverem noutro pacote, preciso especificar:
		@ComponentScan({"com.my.package.first","com.my.package.second"})

	Existem outras formas. Essa acima é uma delas.

> @Data
	Com essa notação não preciso gerar gets e sets.
	inseguro.

> @Entity (import javax.persistence.Entity;)
	Mapeia o objeto com o hibernate indicando que ele virará uma tabela no nosso banco.

	preciso criar um construtor sem parâmetros e um com parâmetros.
	O sem parâmetros é só para satisfazer o JPA.

	Obrigatoriamente tenho que ter o @Data ou os gets e sets para que o JPA consiga
	alterar os atributos da entidade.

> @Id
	marca uma variável como chave primária da relação (tabela)

> @GeneratedValue(strategy = GenerationType.IDENTITY)
	diz qeu o id é id representativo e único.
	E o banco cria o id único para o objeto.  <- mas não é o valor da variável???

> Dao
	Um inferface onde descrevo como uma query deve ser feita.
	Posso usar queries nativas em SQL e também posso utilizar diversas queries padrão
	do JPA

> @Repository
	diz ao spring que essa interface será uma abstração para conexão com o BD.

> @Service
	o service é responsável por maipular o DAO de um objeto, ou seja, o repositório desse objeto

> Exceptions
	Springboot possui um wrapper que permite retornar exceptions para o cliente, caso a requisição
	não saia como esperada.

	criar o pacote das exceções fora do pacote rest.

> @ControllerAdvice
	diz ao spring boot que essa classe é um handler de controle de toda a aplicação.	

	handler: um processo pré configurado que é executado quando uma ação acontece.

> RestExceptionHandler (é uma classe)
	essa classe irá capturar todas as exceções das classes da api, marcadas com @RequestMapping (todas as 
	exceções da API lançadas pelos controllers).
	





